WEB DEVELOPMENT CODECADEMY

-----LECCION 1----- 
WHY TEST?

AUTOMATED TESTING: Automated testing is the use of software to control the execution of tests and the comparison of 
actual behavior to expected behavior. All the testing you just did (and more) could be performed by a computer program.

Compared to manual testing, automated testing is
- Faster: it tests more of your product in less time.
- More reliable: it’s less prone to error than a human is .
- Maintainable: you can review, edit, and extend a collection of tests.

Rather than hire a testing team at the end of development, professional developers can run their automated tests after 
every change. The workflow might look like this:
1. Write code and corresponding tests
2. Enter a command into a terminal to run tests
3. If the app behaves as intended, all tests should pass. Development is complete.
4. If it does not behave as intended, at least one test should fail. Fix code and return to step 2.

TEST SUITES: You run a test suite with 
	npm test 

Test code is included with and structured similarly to implementation code. Often times changes to test 
code are associated with changes to implementation code and vice versa. Both are easier to maintain when they are 
stored in the same place.

For example, if implementation code is written in index.js then the corresponding test code may be written in index-
test.js.

TESTS AS DOCUMENTATION: Tests as documentation provide what many other forms cannot: both human-readable text to 
describe the application and machine-executable code to confirm the app works as described.

This code block from the Cake Bar app describes and tests the “name” functionality.
	it('accepts the customer name', () => {
	  const name = 'Hungry Person';
	 
	  browser.url('/');
	  browser.setValue('#name', name);
	  browser.click('#submit-order');
	  browser.url('/');
	 
	  assert.include(browser.getText('#deliver-to'), name);
	});

You can read the description in plain English terms: it accepts the customer name. You can run the test to confirm 
the functionality works as described.

REGRESSION: When adding a new feature to your product, it’s possible that something will break. If that break occurs 
within a feature developed earlier, it is called regression. When functionality previously developed and tested stops 
working, you may say the functionality regressed.



-----LECCION 2-----
WRITE GOOD TESTS WITH MOCHA

INSTALL MOCHA: Before writing any tests you’ll need to use Node.js and npm to set up a JavaScript project and install 
Mocha.

The following command creates a file package.json that can be used to manage packages for the project.
	$ npm init

After running this command you will be prompted to enter information about your project. With your project setup, you 
can install packages.
	$ npm install mocha -D

-D signifies that this package is a development dependency and will show up under the devDependecies section in 
package.json. This means that the package will only be included in development mode and will not be included in the 
production bundle.

After installing Mocha as a dependency we can run it this way:
The method is to add a script to package.json. In the scripts object in package.json, set the value of "test" to 
mocha. It should look like this:

	"scripts": {
	  "test": "mocha"
	}

Now you can call Mocha with the following command:
	$ npm test

Instead of manually running each test in the test directory, you can use this command to run the full test suite 
automatically.

'DESCRIBE' AND 'IT' BLOCKS: In Mocha we group tests using the describe function and define tests using the it 
function. These two functions can be used to make your test suite complete, maintainable, and expressive in the 
following ways:
- Structure your test suite: you can organize tests into nested groups that reflect the structure of your 
  implementation code.
- Provide informative messages: you can define your tests using human-readable strings.

If you are testing a Math object with the method .max, you could use the following test code.

	describe('Math', () => {
	  describe('.max', () => {
	    it('returns the argument with the highest value', () => {
	      // Your test goes here
	    });
	    it('returns -Infinity when no arguments are provided', () => {
	      // Your test goes here
	    });
	  });
	});

Both the describe and it functions accept two parameters: a descriptive string and a callback function. Though the 
functions are flexible, they are commonly used in the structure above: nest describe blocks to resemble the structure 
of your implementation code and write individual tests in it blocks. This makes your test suite isolated, 
maintainable, and expressive.

ASSERT: In programming, a test compares an expected outcome to an actual outcome. For example, we expect the outcome 
of the following code… 	const a = 1 + 2; 	…to be: a has a value of 3.

assert.ok() allows you to compare values and throw errors as needed using one function call. The small, human-
readable format of the functions will help you make a more expressive test suite.

As a Node module, assert can be imported at the top of your files with
	const assert = require('assert');

You call assert functions like this:
	assert.ok(a === 3);

In this case a === 3 evaluates to true, so no error is thrown.

If an argument passed to assert.ok() evaluates to false, an AssertionError is thrown. The error communicates to Mocha 
that a test has failed, and Mocha logs the error message to the console.

SETUP, EXERCISE, AND VERIFY: This distinct and well-defined separation of steps makes your test more reliable, 
maintainable, and expressive.

The phases are defined as follows:
- Setup - create objects, variables, and set conditions that your test depends on
- Exercise - execute the functionality you are testing
- Verify - check your expectations against the result of the exercise phase. You can use the assert library here

TEARDOWN: Running multiple tests can introduce issues if the tests make changes to the testing environment: changes 
to the environment in one test might affect the next test. Some common changes to an environment include:
- altering files and directory structure
- changing read and write permissions on a file
- editing records in a database

To address this issue, we often add a teardown step to the end of our tests. The teardown phase makes our tests 
isolated by resetting the environment before the next test runs. This provides two key benefits:
- Changes to the environment caused by one test do not affect the other tests.
- Isolated tests can be executed in any order!

HOOKS: The Mocha test framework provides functions that enable us to reduce repetition, simplify the scope of each 
test, and more finely control the execution of our tests.

These functions (also referred to as hooks) are:
- beforeEach(callback) - callback is run before each test
- afterEach(callback) - callback is run after each test
- before(callback) - callback is run before the first test
- after(callback) - callback is run after the last test

Each hook accepts a callback to be executed at various times during a test. The before... hooks naturally happen 
before tests and are useful for separating out the setup steps of your tests. Meanwhile, the after... hooks are 
executed after tests and are useful for separating out the teardown steps of your tests.

	describe('messing around with hooks', () => {
	  let testValue; // Variable used by both tests
	 
	  beforeEach(() => {
	    testValue = 5;
	  });
	 
	  it('should add', () => {
	    // testValue = 5 <-- moved to beforeEach()
	    testValue = testValue + 5;
	    assert.equal(testValue, 10);
	  });
	 
	  it('should multiply', () => {
	    // testValue = 5 <-- moved to beforeEach()
	    testValue = testValue * 5;
	    assert.equal(testValue, 25);
	  });
	});

In this example, while each it() block could have set the testValue to 5, using the beforeEach() hook allows us to 
avoid that repetition while keeping each test isolated.




