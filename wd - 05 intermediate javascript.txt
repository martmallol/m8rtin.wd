WEB DEVELOPMENT CODECADEMY:

-----LECCION 1----- 
MODULES
INTRO TO RUNTIME ENVIROMENTS: A runtime environment is where your program will be executed. It determines what 
global objects your program can access and it can also impact how it runs.
There are runtime environments like:
- the runtime environment of a browser (like Chrome, or Firefox)
- the Node runtime environment

A BROWSER'S RUNTIME ENVIRONMENT: The most common place where JavaScript code is executed is in a browser. For example, 
using any text editor, u could create a file on your computer called my_website.html and put the following code:
<!-- my_website.html -->
<html>
  <body>
    <h1> My Website </h1>
    <script> window.alert('Hello World'); </script>
  </body>
</html>

Most browsers will allow you to load websites that you have created locally by going to the menu 
File > Open File > my_website.html.

Upon loading, the embedded <script></script> will execute and the window.alert() method will create a pop-up box in 
your browser with the text "Hello World". How is this possible?
The answer is that you are executing this code in the browser’s runtime environment. The window.alert() method is 
built into this environment and any program executed in a browser has access to this method. In fact, the window 
object provides access to a huge amount of data and functionality relating to the open browser window beyond 
just .alert().

Applications created for and executed in the browser are known as front-end applications. For a long time, JavaScript 
code could only be executed in a browser and was used exclusively for creating front-end applications. In order to 
create back-end applications that could run on a computer WITHOUT a browser, you would need to use other programming 
languages such as Java or PHP.

NODE RUNTIME ENVIRONMENT: The Node runtime environment was created for the purpose of executing JavaScript code 
without a browser, thus enabling programmers to create full-stack (front-end and back-end) applications using only 
the JavaScript language.

Functions, like window.alert(), can’t be used. Instead, the Node runtime environment gives back-end applications 
access to a variety of features unavailable in a browser, such as access to the server’s file system, database, and 
network. For example, suppose you created a file called my-app.js. We can check to see the directory that this file 
is located in using the Node runtime environment variable process:
	// my-app.js
	console.log(process.env.PWD);

Notice that we are using console.log now instead of window.alert() since the window object isn’t available.
process is an object containing data relating to the JavaScript file being executed. process.env is an object 
containing environment variables such as process.env.PWD which contains the current working directory (and stands 
for “Print Working Directory”).

To execute the JavaScript code in this file, first make sure that you have set up Node on your computer. Then, 
open up a terminal and run the following command:
	$ node my-app.js
	/path/to/working/directory

The node command tells your computer to execute the my-app.js file in the Node environment. You can also use the 
node command without a file argument to open up the Node Read-Eval-Print-Loop (REPL):
	$ node
	> process.env.HOME
	'/home/ccuser'

SUMMARY (FRONT-END vs BACK-END): 
- Front-end JavaScript applications are executed in a browser’s runtime environment and have access to 
  the window object.
- Back-end JavaScript applications are executed in the Node runtime environment and have access to the 
  file system, databases, and networks attached to the server.


-----LECCION 2----- 
IMPLEMENTING MODULES IN NODE
WHAT ARE MODULES?: Modules are reusable pieces of code in a file that can be exported and then imported for use 
in another file. A modular program is one whose components can be separated, used individually, and recombined to 
create a complex system.

This modular strategy is sometimes called separation of concerns and is useful for several reasons. For example:
- find, fix, and debug code more easily.
- keep information private and protected from other modules.
- prevent pollution of the global namespace and potential naming collisions.

NODE.JS VS ES6: There are multiple ways of implementing modules depending on the runtime environment in which your 
code is executed. In JavaScript, there are two runtime environments and each has a preferred module implementation:
- The Node runtime environment and the module.exports and require() syntax.
- The browser’s runtime environment and the ES6 import/export syntax.

IMPLEMENTING THEM IN NODE: Every JS file that runs in a Node environment is treated as a distinct module. The 
functions and data defined within each module can be used by any other module, as long as those resources are 
properly exported and imported.

Imagine we have two programs, *water-limits.js* and *celsius-to-fahrenheit.js*. Both programs implement the function 
celsiusToFahrenheit(). Not only did we write this function twice, but if we ever need to make changes to the function 
we’ll also have to make those changes in two places. 
Creating a module that exports a celsiusToFahrenheit() function that can be used by both of these programs would 
solve this repetitive code problem.

MODULE.EXPORTS: To create a module, you simply have to create a new file where the functions can be declared. Then, 
to make these functions available to other files, add them as properties to the built-in *module.exports* object:

/* converters.js */
function celsiusToFahrenheit(celsius) {                      (1)
  return celsius * (9/5) + 32;                               (2)
}                                                            (3)
                                                             (4)
module.exports.celsiusToFahrenheit = celsiusToFahrenheit;    (5)
                            				     (6)
module.exports.fahrenheitToCelsius = function(fahrenheit) {  (7)
  return (fahrenheit - 32) * (5/9);			     (8)
};							     (9)

The code above demonstrates two ways of exporting functions from a module:
- In the fifth line of code, the first approach for exporting a function is shown. The already-defined function 
  celsiusToFahrenheit() is assigned to module.exports.celsiusToFahrenheit.
- Below, an alternative approach for exporting a function from a module is shown. A new function expression is 
  declared and assigned to module.exports.fahrenheitToCelsius. 

module.exports is an object that is built-in to the Node.js runtime environment. Other files can now import this 
object, and make use of these two functions, with another feature that is built-in to the Node.js runtime 
environment: the require() function.

REQUIRE(): The require() function accepts a string as an argument. That string provides the file path to the module 
you would like to import.

Let’s update water-limits.js such that it uses require() to import the .celsiusToFahrenheit() method from the 
module.exports object within converters.js:

/* water-limits.js */
const converters = require('./converters.js'); 
 
const freezingPointF = converters.celsiusToFahrenheit(0); 	//0 = freezingPointCelsius
const boilingPointF = converters.celsiusToFahrenheit(100); 	//100 = boilingPointCelsius
 
console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);

When you use require(), the entire module.exports object is returned and stored in the variable converters. 
This means that both the .celsiusToFahrenheit() and .fahrenheitToCelsius() methods can be used in this program!

USING OBJECT DESTRUCTURING TO BE MORE SELECTIVE WITH REQUIRE(): In many cases, modules will export a large number 
of functions but only one or two of them are needed. You can use object destructuring to extract only the 
needed functions.

Let’s update celsius-to-fahrenheit.js and only extract the .celsiusToFahrenheit() method, leaving 
.fahrenheitToCelsius() behind:
In the console:
	$ node celsius-to-fahrenheit.js 100 (aca esta el process)
	100 degrees Celsius = 212 degrees Fahrenheit (devuelve esto)

In JS: 
	/* celsius-to-fahrenheit.js */
	const { celsiusToFahrenheit } = require('./converters.js');
 
	const celsiusInput = process.argv[2]; 
	const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
 
	console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);

celsiusInput is assigned process.argv[2]. When a program is executed in the Node environment, process.argv is an 
array holding the arguments provided. In this case, it looks like ['node', 'celsius-to-fahrenheit.js', '100']. 
So, process.argv[2] returns 100.


-----LECCION 2----- 
IMPLEMENTING MODULES - ES6 SYNTAX
BRIEF HISTOYRY OF JAVASCRIPT MODULES IN THE BROWSER: The average size of a website, in terms of kilobytes of 
JavaScript data transferred, has grown over 5 times from 2010 to 2020! This data is to make clear the need for 
modularity as the capabilities, and size, of these scripts grow.

E6S NAMED EXPORT SYNTAX: A module must be entirely contained within a file. So, let’s first consider where a new 
module may be placed within the file system. Since it needs to be used by both of these projects, you may want to 
put it in a mutually accessible location. The entire file structure containing both projects and this new module, 
let’s call it **dom-functions.js**, could look like this:
Files:
	secret-image/
	|-- secret-image.html
	|-- secret-image.js
	secret-messages/
	|-- secret-messages.html
	|-- secret-messages.js
	modules/ (CARPETA DONDE ESTARAN LOS MODULOS)
	|-- dom-functions.js    <-- new module file

Inside dom-functions.js, the functions you wish to reuse can be exported using the named export syntax below:
	export { resourceToExportA, resourceToExportB, ...}

Below, you can see how this is implemented in the new module file dom-functions.js:
/* dom-functions.js */
const toggleHiddenElement = (domElement) => {
    if (domElement.style.display === 'none') {
      domElement.style.display = 'block';
    } else {
      domElement.style.display = 'none';
    }
}
 
const changeToFunkyColor = (domElement) => {
  const r = Math.random() * 255;
  const g = Math.random() * 255;
  const b = Math.random() * 255;
 
  domElement.style.background = `rgb(${r}, ${g}, ${b})`;
}
 
export { toggleHiddenElement, changeToFunkyColor }; <---------- (ES6 export statement)

These exported functions are now available to be imported and used by other JS files!

INDIVIDUAL EXPORT: In addition to the syntax above, in which all named exports are listed together, individual 
values may be exported as named exports by simply placing the export keyword in front of the variable’s declaration. 
Here is the same example using this syntax:

/* dom-functions.js */
export const toggleHiddenElement = (domElement) => {
  // logic omitted...
}
 
export const changeToFunkyColor = (domElement) => {
  // logic omitted...
}

HOW TO CREATE A LOCAL SERVER WITH VS CODE: 
https://www.codecademy.com/articles/spinning-up-a-local-server

ES6 IMPORT SYNTAX: The ES6 syntax for importing named resources from modules is similar to the export syntax:
	import { exportedResourceA, exportedResourceB } from '/path/to/module.js';

Let’s update the secret-messages program such that it now imports functionality from dom-functions.js:

/* secret-messages.js */
import { toggleHiddenElement, changeToFunkyColor } from '../modules/dom-functions.js';
 
const buttonElement = document.getElementById('secret-button');
const pElement = document.getElementById('secret-p');
 
buttonElement.addEventListener('click', () => {
  toggleHiddenElement(pElement);     <-------------
  changeToFunkyColor(buttonElement); <-------------
});

Now, you must also update secret-messages.html:
(last sentence in the <body> element)
	<script type="module" src="./secret-messages.js"> </script>

Not putting type="module" to the <script> element can cause some browsers to throw an error. 

RENAMNIG IMPORTS TO AVOID NAMING COLLISIONS: suppose you had access to two modules, greeterEspanol.js and 
greeterFrancais.js. Each exports a function called greet():

/* inside greeterEspanol.js */
const greet = () => {
  console.log('hola');
}
export { greet };
 
/* inside greeterFrancais.js */
const greet = () => {
  console.log('bonjour');
}
export { greet };

Now, let’s say you wanted to use each of these functions in a program, called main.js, that simulates a conversation 
between a spanish-speaker and a french-speaker.
	import { greet } from 'greeterEspanol.js';
	import { greet } from 'greeterFrancais.js';

The code above will throw an error on line 2 due to the fact that the identifier greet has already been defined on 
line 1. Thankfully, ES6 includes syntax for renaming imported resources by adding in the keyword **as**. 
It looks like this:
/* main.js */
import { greet as greetEspanol } from 'greeterEspanol.js';
import { greet as greetFrancais } from 'greeterFrancais.js';
 
greetEspanol(); // Prints: hola
greetFrancais(); // Prints: bonjour

DEFAULT EXPORTS AND IMPORTS: Every module also has the option to export a single value to represent the entire 
module called the default export. Often, though not always, the default export value is an object containing the 
entire set of functions and/or data values of a module.
The syntax for exporting a default object looks like this:

const resources = { 
  valueA, 
  valueB 
}
export { resources as default };

At first glance, it looks like the resources object is being exported as a named export. However, the clause as 
default renames the exported object to default, a reserved identifier that can only be given to a single exported 
value.

You may also see this shorthand syntax where the value that follows 'export default' is the default value 
to be exported:

const resources = {
  valueA,
  valueB
}
export default resources;

IMPORTING DEFAULT VALUES: The syntax for importing default exports looks like this:
	import importedResources from 'module.js';

This syntax is actually shorthand for 'import { default as importedResources } from 'module.js' and the imported 
'default' value may be given any name the programmer chooses.

It should be noted that if the default export is an object, the values inside cannot be extracted until after 
the object is imported, like so:

// This will work...
import resources from 'module.js'
const { valueA, valueB } = resources;
 
// This will not work...
import { valueA, valueB } from 'module.js'

The dom-functions.js module from above could be rewritten to use default exports like so:
	export default resources;
This default exports object can now be used within secret-messages.js like so:
	import domFunctions from '../modules/dom-functions.js';
	const { toggleHiddenElement, changeToFunkyColor } = domFunctions;

Notice how toggleHiddenElement() and changeToFunkyColor() are now methods of the imported object called 
'domFunctions' and are extracted using ES6 destructuring syntax!
