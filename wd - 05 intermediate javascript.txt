WEB DEVELOPMENT CODECADEMY:

-----LECCION 1----- 
MODULES
INTRO TO RUNTIME ENVIROMENTS: A runtime environment is where your program will be executed. It determines what 
global objects your program can access and it can also impact how it runs.
There are runtime environments like:
- the runtime environment of a browser (like Chrome, or Firefox)
- the Node runtime environment

A BROWSER'S RUNTIME ENVIRONMENT: The most common place where JavaScript code is executed is in a browser. For example, 
using any text editor, u could create a file on your computer called my_website.html and put the following code:
<!-- my_website.html -->
<html>
  <body>
    <h1> My Website </h1>
    <script> window.alert('Hello World'); </script>
  </body>
</html>

Most browsers will allow you to load websites that you have created locally by going to the menu 
File > Open File > my_website.html.

Upon loading, the embedded <script></script> will execute and the window.alert() method will create a pop-up box in 
your browser with the text "Hello World". How is this possible?
The answer is that you are executing this code in the browser’s runtime environment. The window.alert() method is 
built into this environment and any program executed in a browser has access to this method. In fact, the window 
object provides access to a huge amount of data and functionality relating to the open browser window beyond 
just .alert().

Applications created for and executed in the browser are known as front-end applications. For a long time, JavaScript 
code could only be executed in a browser and was used exclusively for creating front-end applications. In order to 
create back-end applications that could run on a computer WITHOUT a browser, you would need to use other programming 
languages such as Java or PHP.

NODE RUNTIME ENVIRONMENT: The Node runtime environment was created for the purpose of executing JavaScript code 
without a browser, thus enabling programmers to create full-stack (front-end and back-end) applications using only 
the JavaScript language.

Functions, like window.alert(), can’t be used. Instead, the Node runtime environment gives back-end applications 
access to a variety of features unavailable in a browser, such as access to the server’s file system, database, and 
network. For example, suppose you created a file called my-app.js. We can check to see the directory that this file 
is located in using the Node runtime environment variable process:
	// my-app.js
	console.log(process.env.PWD);

Notice that we are using console.log now instead of window.alert() since the window object isn’t available.
process is an object containing data relating to the JavaScript file being executed. process.env is an object 
containing environment variables such as process.env.PWD which contains the current working directory (and stands 
for “Print Working Directory”).

To execute the JavaScript code in this file, first make sure that you have set up Node on your computer. Then, 
open up a terminal and run the following command:
	$ node my-app.js
	/path/to/working/directory

The node command tells your computer to execute the my-app.js file in the Node environment. You can also use the 
node command without a file argument to open up the Node Read-Eval-Print-Loop (REPL):
	$ node
	> process.env.HOME
	'/home/ccuser'

SUMMARY (FRONT-END vs BACK-END): 
- Front-end JavaScript applications are executed in a browser’s runtime environment and have access to 
  the window object.
- Back-end JavaScript applications are executed in the Node runtime environment and have access to the 
  file system, databases, and networks attached to the server.


-----LECCION 2----- 
IMPLEMENTING MODULES IN NODE
WHAT ARE MODULES?: Modules are reusable pieces of code in a file that can be exported and then imported for use 
in another file. A modular program is one whose components can be separated, used individually, and recombined to 
create a complex system.

This modular strategy is sometimes called separation of concerns and is useful for several reasons. For example:
- find, fix, and debug code more easily.
- keep information private and protected from other modules.
- prevent pollution of the global namespace and potential naming collisions.

NODE.JS VS ES6: There are multiple ways of implementing modules depending on the runtime environment in which your 
code is executed. In JavaScript, there are two runtime environments and each has a preferred module implementation:
- The Node runtime environment and the module.exports and require() syntax.
- The browser’s runtime environment and the ES6 import/export syntax.

IMPLEMENTING THEM IN NODE: Every JS file that runs in a Node environment is treated as a distinct module. The 
functions and data defined within each module can be used by any other module, as long as those resources are 
properly exported and imported.

Imagine we have two programs, *water-limits.js* and *celsius-to-fahrenheit.js*. Both programs implement the function 
celsiusToFahrenheit(). Not only did we write this function twice, but if we ever need to make changes to the function 
we’ll also have to make those changes in two places. 
Creating a module that exports a celsiusToFahrenheit() function that can be used by both of these programs would 
solve this repetitive code problem.

MODULE.EXPORTS: To create a module, you simply have to create a new file where the functions can be declared. Then, 
to make these functions available to other files, add them as properties to the built-in *module.exports* object:

/* converters.js */
function celsiusToFahrenheit(celsius) {                      (1)
  return celsius * (9/5) + 32;                               (2)
}                                                            (3)
                                                             (4)
module.exports.celsiusToFahrenheit = celsiusToFahrenheit;    (5)
                            				     (6)
module.exports.fahrenheitToCelsius = function(fahrenheit) {  (7)
  return (fahrenheit - 32) * (5/9);			     (8)
};							     (9)

The code above demonstrates two ways of exporting functions from a module:
- In the fifth line of code, the first approach for exporting a function is shown. The already-defined function 
  celsiusToFahrenheit() is assigned to module.exports.celsiusToFahrenheit.
- Below, an alternative approach for exporting a function from a module is shown. A new function expression is 
  declared and assigned to module.exports.fahrenheitToCelsius. 

module.exports is an object that is built-in to the Node.js runtime environment. Other files can now import this 
object, and make use of these two functions, with another feature that is built-in to the Node.js runtime 
environment: the require() function.

REQUIRE(): The require() function accepts a string as an argument. That string provides the file path to the module 
you would like to import.

Let’s update water-limits.js such that it uses require() to import the .celsiusToFahrenheit() method from the 
module.exports object within converters.js:

/* water-limits.js */
const converters = require('./converters.js'); 
 
const freezingPointF = converters.celsiusToFahrenheit(0); 	//0 = freezingPointCelsius
const boilingPointF = converters.celsiusToFahrenheit(100); 	//100 = boilingPointCelsius
 
console.log(`The freezing point of water in Fahrenheit is ${freezingPointF}`);
console.log(`The boiling point of water in Fahrenheit is ${boilingPointF}`);

When you use require(), the entire module.exports object is returned and stored in the variable converters. 
This means that both the .celsiusToFahrenheit() and .fahrenheitToCelsius() methods can be used in this program!

USING OBJECT DESTRUCTURING TO BE MORE SELECTIVE WITH REQUIRE(): In many cases, modules will export a large number 
of functions but only one or two of them are needed. You can use object destructuring to extract only the 
needed functions.

Let’s update celsius-to-fahrenheit.js and only extract the .celsiusToFahrenheit() method, leaving 
.fahrenheitToCelsius() behind:
In the console:
	$ node celsius-to-fahrenheit.js 100 (aca esta el process)
	100 degrees Celsius = 212 degrees Fahrenheit (devuelve esto)

In JS: 
	/* celsius-to-fahrenheit.js */
	const { celsiusToFahrenheit } = require('./converters.js');
 
	const celsiusInput = process.argv[2]; 
	const fahrenheitValue = celsiusToFahrenheit(celsiusInput);
 
	console.log(`${celsiusInput} degrees Celsius = ${fahrenheitValue} degrees Fahrenheit`);

celsiusInput is assigned process.argv[2]. When a program is executed in the Node environment, process.argv is an 
array holding the arguments provided. In this case, it looks like ['node', 'celsius-to-fahrenheit.js', '100']. 
So, process.argv[2] returns 100.








