WEB DEVELOPMENT CODECADEMY:

GIT CHEATSHEET: https://education.github.com/git-cheat-sheet-education.pdf
MARKDOWN CHEATSHEET: https://docs.github.com/en/github/writing-on-github/getting-started-with-writing-and-formatting-on-github/basic-writing-and-formatting-syntax
ANOTHER MARKDOWN CHEATSHEET: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet

-----LECCION 1----- 
BASIC GIT WORKFLOW
Git is a software that allows you to keep track of changes made to a project over time. Git works by recording the 
changes you make to a project, storing those changes, then allowing you to reference them as needed.

GIT INIT: Now that we have started working on the screenplay, let’s turn the sorcerers-code directory into a Git 
project. We do this with:
  git init

The word 'init' means 'initialize'. The command sets up all the tools Git needs to begin tracking changes made to 
the project.

GIT WORKFLOW: Nice! We have a Git project. A Git project can be thought of as having three parts:
1. A Working Directory: where you’ll be doing all the work: creating, editing, deleting and organizing files
2. A Staging Area: where you’ll list changes you make to the working directory
3. A Repository: where Git permanently stores those changes as different versions of the project

The Git workflow consists of editing files in the working directory, adding files to the staging area, and saving 
changes to a Git repository. In Git, we save changes with a commit.

GIT STATUS: As you write the screenplay, you will be changing the contents of the working directory. 
You can check the status of those changes with:
  git status

GIT ADD: In order for Git to start tracking scene-1.txt, the file needs to be added to the staging area.
We can add a file to the staging area with:
  git add filename (The word *filename* here refers to the name of the file you are editing, such as scene-1.txt.)

GIT DIFF: Imagine that we type another line in scene-1.txt. Since the file is tracked, we can check the differences 
between the working directory and the staging area with:
  git diff filename

Here, filename is the actual name of the file. If the name of my file was changes.txt the command would be
  git diff changes.txt

GIT COMMIT: A commit is the last step in our Git workflow. A commit permanently stores changes from the staging 
area inside the repository. One more bit of code is needed for a commit: the option -m followed by a message. 
Here’s an example:
  git commit -m "Complete first line of dialogue"

Standard Conventions for Commit Messages:
  - Must be in quotation marks
  - Written in the present tense
  - Should be brief (50 characters or less) when using -m

GIT LOG: Often with Git, you’ll need to refer back to an earlier version of a project. 
Commits are stored chronologically in the repository and can be viewed with:
  git log

In the output, notice:
  - A 40-character code, called a SHA, that uniquely identifies the commit. This appears in orange text.
  - The commit author (you!)
  - The date and time of the commit
  - The commit message

REVIEW: 
Use Git commands to help keep track of changes made to a project:
  - git init:   creates a new Git repository
  - git status: inspects the contents of the working directory and staging area
  - git add:    adds files from the working directory to the staging area
  - git diff:   shows the difference between the working directory and the staging area
  - git commit: permanently stores file changes from the staging area in the repository
  - git log:    shows a list of all previous commits

SETUP WITH GIT AND GITHUB: https://www.codecademy.com/paths/web-development/tracks/learn-git/modules/learn-git-git-workflow-u/articles/f1-u3-git-setup

GIT & GITHUB: https://www.youtube.com/watch?v=-sMmrYTtQgE&t=116s


-----LECCION 2----- 
HOW TO BACKTRACK
BACKTRACKING INTRO: When working on a Git project, sometimes we make changes that we want to get rid of. Git offers 
a few eraser-like features that allow us to undo mistakes during project creation. 

HEAD COMMIT: In Git, the commit you are currently on is known as the HEAD commit. In many cases, the most recently 
made commit is the HEAD commit.

To see the HEAD commit, enter:
  git show HEAD

The output of this command will display everything the git log command displays for the HEAD commit, plus all the 
file changes that were committed.

GIT CHECKOUT: What if you decide to change the ghost’s line in the working directory, but then decide you wanted 
to discard that change? You could rewrite the line how it was originally, but what if you forgot the exact wording? 
The below will restore the file in your working directory to look exactly as it did when you last made a commit.
  git checkout HEAD filename

MORE GIT ADD: You can add multiple files like this: 
  git add filename_1 filename_2

GIT RESET I: What if, before you commit, you accidentally delete an important line from scene-2.txt? Unthinkingly, 
you add scene-2.txt to the staging area and you don’t want to include it in the commit. We can unstage that file 
from the staging area using:
  git reset HEAD filename

This command resets the file in the staging area to be the same as the HEAD commit. It does not discard file 
changes from the working directory, it just removes them from the staging area.

GIT RESET II: Just like retracing your steps on a hike, Git enables you to rewind to the part before you made the 
wrong turn. You can do this with:
  git reset commit_SHA

This command works by using the first 7 characters of the SHA of a previous commit. For example, if the SHA of the 
previous commit is 5d692065cf51a2f50ea8e7b19b5a7ae512f633ba, use:
  git reset 5d69206
HEAD is now set to that previous commit.

REVIEW: 
Let’s take a moment to review the new commands:
  - git checkout HEAD filename: Discards changes in the working directory. 
                                (el archivo vuelve a como estaba antes de los cambios)
  - git reset HEAD filename: Unstages file changes in the staging area.
                             (el archivo sale de la pila de archivos a commitear)
  - git reset commit_SHA: Resets to a previous commit in your commit history.


-----LECCION 3----- 
BRANCHING
GIT BRANCH: Git allows us to create branches to experiment with versions of a project. Imagine you want to create 
version of a story with a happy ending. You can create a new branch and make the happy ending changes to that 
branch only. It will have no effect on the master branch until you’re ready to merge the happy ending to the 
master branch.

You can use the command below to answer the question: “which branch am I on?”:
  git branch

To create a new branch, use:
  git branch new_branch

Be sure to name your branch something that describes the purpose of the branch. Also, branch names can’t contain 
whitespaces: *new-branch* and *new_branch* are valid branch names, but *new branch* is not.

GIT CHECKOUT: You can switch to the new branch with
  git checkout branch_name

Once you switch branches, you will now be able to make commits on the branch that have no impact on master. You can 
continue your workflow, while master stays intact!

GIT MERGE: What if you wanted include all the changes made to the 'fencing' branch on the 'master' branch? We can 
easily accomplish this by merging the branch into 'master' with:
  git merge fencing

Keep in mind:
  - Your goal is to update master with changes you made to fencing.
  - fencing is the giver branch, since it provides the changes.
  - master is the receiver branch, since it accepts those changes.

MERGE CONFLICTS: The merge was successful because 'master' had not changed since we made a commit on 'fencing'. Git 
knew to simply update 'master' with changes on 'fencing'.

What would happen if you made a commit on 'master' before you merged the two branches? Furthermore, what if the 
commit you made on 'master' altered the same exact text you worked on in 'fencing'? When you switch back to 
'master' and ask Git to merge the two branches, Git doesn’t know which changes you want to keep. 
This is called a 'merge conflict'.

Let’s say you decide you’d like to merge the changes from 'fencing' into 'master'. Here’s where the trouble begins!
You’ve made commits on separate branches that alter the same line in conflicting ways. Now, when you try to merge 
'fencing' into 'master', Git will not know which version of the file to keep.

FIXING THE MERGE CONFLICT: We must fix the merge conflict. In the code editor, look at 'resume.txt'. Git uses 
markings to indicate the HEAD (master) version of the file and the fencing version of the file, like this:
  <<<<<<< HEAD
  master version of line
  =======
  fencing version of line
  >>>>>>> fencing

Git asks us which version of the file to keep: the version on 'master' or the version on 'fencing'. You decide you
want the 'fencing' version.

From the code editor:
  - Delete the content of the line as it appears in the master branch
  - Delete all of Git’s special markings including the words HEAD and fencing. If any of Git’s markings remain, 
    for example, >>>>>>> and =======, the conflict remains.
Then you add 'resume.txt' to the staging area and you commit it with a message like "Resolve merge conflict"

DELETE BRANCH: In Git, branches are usually a means to an end. You create them to work on a new project feature, 
but the end goal is to merge that feature into the master branch. After the branch has been integrated into 
'master', it has served its purpose and can be deleted.
The command below will delete the specified branch from your Git project:
  git branch -d branch_name

REVIEW:
The following commands are useful in the Git branch workflow.
  - git branch: Lists all a Git project’s branches.
  - git branch branch_name: Creates a new branch.
  - git checkout branch_name: Used to switch from one branch to another.
  - git merge branch_name: Used to join file changes from one branch to another.
  - git branch -d branch_name: Deletes the branch specified.



-----LECCION 4----- 
GIT TEAMWORK
REMOTES: A remote is a shared Git repository that allows multiple collaborators to work on the same Git project 
from different locations. Collaborators work on the project independently, and merge changes together when they 
are ready to do so.

GIT CLONE: Sally has created the remote repository, science-quizzes in the directory curriculum, which teachers on 
the school’s shared network have access to. In order to get your own replica of science-quizzes, you’ll need to 
clone it with:
  git clone remote_location clone_name

- remote_location tells Git where to go to find the remote. This could be a web address, or a filepath, such as:
     /Users/teachers/Documents/some-remote
- clone_name is the name you give to the directory (local) in which Git will clone the repository.

GIT REMOTE -V: We have a clone of Sally’s remote on our computer. One thing that Git does behind the scenes when 
you clone science-quizzes is give the remote address the name origin, so that you can refer to it more conveniently. 
In this case, Sally’s remote is origin.

You can see a list of a Git project’s remotes with the command:
   git remote -v

Notice the output:
    origin    /home/ccuser/workspace/curriculum/science-quizzes (fetch)
    origin    /home/ccuser/workspace/curriculum/science-quizzes (push)
- Git lists the name of the remote, origin, as well as its location.
- Git automatically names this remote origin, because it refers to the remote repository of origin. However, it is 
  possible to safely change its name.
- The remote is listed twice: once for (fetch) and once for (push). We’ll learn about these later in the lesson.

GIT FETCH: After you cloned science-quizzes, you had to run off to teach a class. Now that you’re back at your 
computer, there’s a problem: what if, while you were teaching, Sally changed the science-quizzes Git project in 
some way. If so, your clone will no longer be up-to-date.

An easy way to see if changes have been made to the remote and bring the changes down to your local copy is with:
   git fetch

This command will not merge changes from the remote into your local repository. 
It brings those changes onto what’s called a remote branch.

MERGE THE FETCHED CHANGES:  Even though Sally’s new commits have been fetched to your local copy of the Git project, 
those commits are on the origin/master branch. Your local master branch has not been updated yet, so you can’t view
or make changes to any of the work she has added.
We’ll use the git merge command to integrate origin/master into your local master branch. The command:
   git merge origin/master

GIT WORKFLOW: The workflow for Git collaborations typically follows this order:
1. Fetch and merge changes from the remote
2. Create a branch to work on a new project feature
3. Develop the feature on your branch and commit your work
4. Fetch and merge from the remote again (in case new commits were made while you were working)
5. Push your branch up to the remote for review

GIT PUSH: Now it’s time to share our work with Sally.

The command:
   git push origin your_branch_name
will push your branch up to the remote, origin. From there, Sally can review your branch and merge your work into 
the master branch, making it part of the definitive project version.

In the output, notice the line:
   To /home/ccuser/workspace/curriculum/science-quizzes
    * [new branch]      bio-questions -> bio-questions

Git informs us that the branch bio-questions was pushed up to the remote. Sally can now review your new work and 
can merge it into the remote’s master branch.

REVIEW:
- git clone: Creates a local copy of a remote.
- git remote -v: Lists a Git project’s remotes.
- git fetch: Fetches work from the remote into the local copy.
- git merge origin/master: Merges origin/master into your local branch.
- git push origin <branch_name>: Pushes a local branch to the origin remote.



-----LECCION 5-----
HANDY GIT OPERATIONS
GIT STASH: A good way to handle this is by using git stash, which allows you to get back to a clean commit point 
with a synchronized working tree, and avoid losing your local changes in the process. You’re “stashing” your local 
work temporarily in order to update a previous commit and later on retrieve your work.

While working on a file, you find a small bug in a separate file from a previous commit that needs to be fixed 
before you continue.
	$ git stash

Running the command above will store your work temporarily for later use in a hidden directory. At this point, you 
can switch branches and do work elsewhere.

Once the bug is fixed, you want to retrieve the code you were working on previously, you can “pop” the work that 
was stored when you used git stash.
	$ git stash pop

From here, you can continue your work and commit it when ready.

MORE GIT LOG'S!:
- git log --oneline: shows the list of commits in one line format.
- git log -S "keyword": displays a list of commits that contain the keyword in the message.
- git log --oneline --graph: --graph Displays a visual representation of how the branches and commits were created 
    in order to help you make sense of your repository history. When used alone, the description can be very 
    lengthy, so you can combine the command with --oneline in order to shorten the description.

GIT COMMIT AMMEND: Git’s --amend flag is extremely useful when updating a commit, it allows you to correct mistakes 
and edit commits easily instead of creating a completely new one.

You could technically create a new commit, but ideally, you want to keep all commits specific, clean, and succinct. 
To avoid creating a new one, you could create your changes, stage them with git add and then type the command git 
commit --amend to update your previous commit.

It’s important to note that although it seems like --amend is simply updating the commit, what Git actually does is 
replace the whole previous commit. For this reason, when you execute the command git commit --amend, your terminal 
editor asks you to update your commit message.

However, if you want to keep the same commit message, you can simply add the flag --no-edit:
	$ git commit --amend --no-edit
	
GIT ALIAS COMMANDS: If you have a set of commands that you use regularly and want to save some time from typing 
them, you can easily set up an alias for each command using Git config.

Below are a couple of examples:
	$ git config --global alias.co "checkout"
	$ git config --global alias.br "branch"
	$ git config --global alias.glop "log --pretty=format:"%h %s" --graph"

Once the aliases are configured, next time you want to check out to another branch you could type the command:
	$ git co example_branch

Instead of:
	$ git checkout example_branch



-----LECCION 6-----
GITHUB & MARKDOWN (.md)

WHAT IS MARKDOWN?: https://www.youtube.com/watch?v=f49LJV1i-_w	

Markdown provides a lightweight syntax to style any text document so that it can be converted to HTML for viewing 
and publishing. (como Latex ponele)

The authors of Markdown intended Markdown to be a language for writing styled text with syntax that is just as easy 
to read as it is to write.

Imagine that we are writing down some important text on a sheet of paper. If we wanted to emphasize the text we 
might underline it, twice even! Similarly, in Markdown, we could write:

Title of My Document
====================

Notice that we have plain text that has a row of equal signs (=) to produce a first-level header, also known as 
<h1>. 

WHEN TO USE MARKDOWN: After knowing the many benefits of Markdown, you might want to consider using Markdown if you 
ever find yourself in any of these scenarios:

The only editor available to you supports just plain text.
Time is of the essence and you can’t afford to learn how to use an unfamiliar rich-text editor.
You need to quickly outline your ideas in a structured but presentable manner.
You want your document to be portable so that it can convert to HTML, PDF, EPUB, and/or MOBI.

THE MARKDOWN PARSER: A Markdown parser is software written to parse the Markdown syntax in a text document and 
convert it to HTML syntax. A basic Markdown parser should support the core Markdown syntax: paragraphs, headers, 
blockquotes, phrase emphasis, lists, code, images, and links.

MARKDOWN TUTORIAL:

HEADINGS: You can simulate a <h1> HTML tag with a # Markdown symbol. Since there are six heading tags for HTML, 
from <h1> through <h6>, you can simulate this with # through ###### in Markdown. For example this Markdown syntax:

	# This is a H1 heading
	## This is a H2 heading
	### This is a H3 heading
	#### This is a H4 heading
	##### This is a H5 heading
	###### This is a H6 heading

BULLETED LISTS (LISTA DE PUNTOS): In addition to numbered lists, you can style a bulleted list too. There are three 
different symbols you can use to mark a line item as a bullet: asterisk (*), plus sign (+), or hyphen (-).

For example:
	* Markdown
	+ HTML
	- XML

For best practice, it is recommended to use the same marker throughout your list instead of mixing them like above.

NESTED LISTS: The core Markdown syntax does not include nested lists (list within another list), but it allows 
adding paragraphs between list items. To do so, you need to add a blank line after a list item and indent 4 spaces 
or 1 tab before starting a paragraph. Some parsers are lenient and do not enforce 4 spaces but there should be some 
spacing.

EJ	* Markdown
	 
	   Markdown is a lightweight markup language for styling text.
	 
	* HTML
	 
	   HTML stands for HyperText Markup Language.

THE MARKDOWN FLAVORS: Many independent developers have extended the Markdown syntax to incorporate more HTML 
compatibilities and customize it for their own organizations. Here are a few popular flavors of Markdown:

- CommonMark is a body of special-interest developers who work side-by-side on a proposal to standardize the 
  Markdown syntax and offer extensive test suites to validate Markdown implementations against this specification. 
  This standard has been used by other developers to base their code upon.

- GitHub Flavored Markup, or GFM is GitHub’s expanded dialect of Markdown based on CommonMark and is used 
  throughout the GitHub platform by its active community.

- Trello, a popular collaborative tool that organizes and tracks information through virtual boards and cards, 
  implements a custom version of Markdown as well.



-----LECCION 7-----
MASTERING MARKDOWN

STYLING TEXT: 

       Style               Syntax			Example	

Bold:			  ** ** or __ __	**This is bold text**	
Italic:		  * * or _ _   	*This text is italicized*	
Strikethrough:		  ~~ ~~		~~This was mistaken text~~	
Bold and nested italic:  ** ** and _ _	**This text is _extremely_ important**
All bold and italic:	  *** ***		***All this text is important***	

QUOTING TEXT: You can quote text with a >.

	Text that is not a quote

	> Text that is a quote

QUOTING CODE!: You can call out code or a command within a sentence with single backticks. The text within the 
backticks will not be formatted. You can also press the command or Ctrl + e keyboard shortcut to insert the 
backticks for a code block within a line of Markdown.

	Use `git status` to list all new or modified files that haven't yet been committed.

Aca el bloque "git status" se vuelve formato codigo (lo rodea un recuadro)

CODE BLOCK: (como en jupyter lab) To format code or text into its own distinct block, use triple backticks.

	Some basic Git commands are:
	```	<-- ACA!!
	git status
	git add
	git commit
	```	<-- ACA!!

LINKS: You can create an inline link by wrapping link text in brackets [ ], and then wrapping the URL in 
parentheses ( ). You can also use the keyboard shortcut command + k to create a link. 

	This site was built using [GitHub Pages](https://pages.github.com/).

RELATIVE LINKS: You can define relative links and image paths in your rendered files to help readers navigate to 
other files in your repository.

A relative link is a link that is relative to the current file. For example, if you have a README file in root of 
your repository, and you have another file in docs/CONTRIBUTING.md, the relative link to CONTRIBUTING.md in your 
README might look like this:

	[Contribution guidelines for this project](docs/CONTRIBUTING.md)

You can use all relative link operands, such as ./ and ../.

IMAGES: You can display an image by adding ! and wrapping the alt text in[ ]. Then wrap the link for the image in 
parentheses ().

	![This is an image](https://myoctocat.com/assets/images/base-octocat.svg)

Tip: When you want to display an image which is in your repository, you should use relative links instead of 
absolute links.

Here are some examples for using relative links to display an image.

Context							Relative Link

In a .md file on the same branch				/assets/images/electrocat.png

In a .md file on another branch				/../main/assets/images/electrocat.png

In issues, pull requests and comments of the repository	../blob/main/assets/images/electrocat.png

In a .md file in another repository				/../../../../github/docs/blob/main/assets/images
								/electrocat.png
In issues, pull requests and comments of another repository	../../../github/docs/blob/main/assets/images/
								electrocat.png?raw=true
IMAGE THEME: You can specify the theme an image is displayed to by appending #gh-dark-mode-only or #gh-light-mode-
only to the end of an image URL, in Markdown. This is particularly helpful for transparent PNG images.

Context	URL
Dark Theme	![GitHub Light](https://github.com/github-light.png#gh-dark-mode-only)
Light Theme	![GitHub Dark](https://github.com/github-dark.png#gh-light-mode-only)

TASKS LISTS: To create a task list, preface list items with a regular space character followed by [ ]. To mark a 
task as complete, use [x].

	- [x] #739
	- [ ] https://github.com/octo-org/octo-repo/issues/740
	- [ ] Add delight to the experience when all tasks are complete :tada:

If a task list item description begins with a parenthesis, you'll need to escape it with \:
	- [ ] \(Optional) Open a followup issue

MENTIONING PEOPLE AND TEAMS: You can mention a person or team on GitHub by typing @ plus their username or team 
name. This will trigger a notification and bring their attention to the conversation. People will also receive a 
notification if you edit a comment to mention their username or team name.
	
	@github/support What do you think about these updates?

When you mention a parent team, members of its child teams also receive notifications, simplifying communication 
with multiple groups of people. For teams, enter the @organization/team-name and all members of that team will get 
subscribed to the conversation.

REFERENCING ISSUES OR PULL REQUESTS: You can bring up a list of suggested issues and pull requests within the 
repository by typing #. Type the issue or pull request number or title to filter the list, and then press either 
tab or enter to complete the highlighted result.

REFERENCING EXTERNAL RESOURCES: If custom autolink references are configured for a repository, then references to 
external resources, like a JIRA issue or Zendesk ticket, convert into shortened links. To know which autolinks are 
available in your repository, contact someone with admin permissions to the repository. 

UPLOADING ASSETS: You can upload assets like images by dragging and dropping, selecting from a file browser, or 
pasting. You can upload assets to issues, pull requests, comments, and .md files in your repository.

USING EMOJI: You can add emoji to your writing by typing :EMOJICODE:.

	@octocat :+1: <-ACA! This PR looks great - it's ready to merge! :shipit: <-ACA!

Typing : will bring up a list of suggested emoji. The list will filter as you type, so once you find the emoji 
you're looking for, press Tab or Enter to complete the highlighted result.

PARAGRAPHS: You can create a new paragraph by leaving a blank line between lines of text.

FOOTNOTES: You can add footnotes to your content by using this bracket syntax:

	Here is a simple footnote[^1].	<-- NUMERO DE LA REFE
	
	A footnote can also have multiple lines[^2].  <-- NUMERO DE LA REFE
	
	You can also use words, to fit your writing style more closely[^note]. <-- NUMERO DE LA REFE
	
	[^1]: My reference.	<-- PRIMERA REFE
	[^2]: Every new line should be prefixed with 2 spaces.	<-- SEGUNDA REFE  
	  This allows you to have a footnote with multiple lines.
	[^note]:	<-- TERCERA REFE
	    Named footnotes will still render with numbers instead of the text but allow easier identification and 	linking.  
	    This footnote also has been made with a different syntax using 4 spaces for new lines.

HIDING CONTENT WITH COMMENTS: You can tell GitHub to hide content from the rendered Markdown by placing the content 
in an HTML comment.

	<!-- This content will not appear in the rendered Markdown -->

IGNORING MARKDOWN FORMATTING: You can tell GitHub to ignore (or escape) Markdown formatting by using \ before the 
Markdown character.

	Let's rename \*our-new-project\* to \*our-old-project\*.

Se lee  Let's rename *our-new-project* to *our-old-project*

TABLES: Tables aren't part of the core Markdown spec, but they are part of GFM and Markdown Here supports them. 
They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from 
another application.

Colons can be used to align columns.

	| Tables        | Are           | Cool  |
	| ------------- |:-------------:| -----:|
	| col 3 is      | right-aligned | $1600 |
	| col 2 is      | centered      |   $12 |
	| zebra stripes | are neat      |    $1 |

There must be at least 3 dashes separating each header cell.
The outer pipes (|) are optional, and you don't need to make the 
raw Markdown line up prettily. You can also use inline Markdown.

	Markdown | Less | Pretty
	--- | --- | ---
	*Still* | `renders` | **nicely**
	1 | 2 | 3

This will still work, though it won't look pretty in the .md raw file

HORIZONTAL RULE (separador horizontal): 
	Three or more...
	
	---	<-- ACA!!
	
	Hyphens

	***	<-- ACA!!

	Asterisks

	___	<-- ACA!!

	Underscores
	


-----LECCION 8-----
DEPLOYING TO GITHUB PAGES

There are many different ways to deploy a website to the public Internet. We’ll be using GitHub’s free service 
called GitHub Pages.

Why GitHub Pages? GitHub Pages offers a lot of features and flexibility, all for free. Some of the benefits include:
- Easy setup
- Seamless collaboration using Git and GitHub
- Free hosting with >95% uptime
- Live updating with normal GitHub workflow

WHAT IS DEPLOYING: Deploying is like publishing. When authors are ready for their work to be seen by the world, 
they publish it. When web developers are ready to share their projects, they deploy to the World Wide Web. 
Deployment is when a project is packaged and shared on the Internet. Unlike publishing, however, deployment may 
occur many, many times over the course of a software project.

DEPLOYMENT ON GITHUB PAGES: Deploying to GitHub Pages is automatic. Once it’s set up, deploying happens whenever 
you push your local changes to your remote, GitHub-hosted repository. Head to GitHub Pages’ setup instructions 
(https://pages.github.com/) and follow the steps exactly to get your main GitHub Pages page setup.

VIEWING YOUR LIVE PAGE: That’s it! Your website is deployed to the Internet! You and anyone with whom you share 
this link can view your project by navigating in your browser to the URL http://<your-github-username>.github.io.

ADDING GITHUB PAGES PROJECTS: You can set up your GitHub Pages to deploy every one of your repositories in addition 
to <username>.github.io. This will allow you to ensure all of your sites are deployed automatically whenever you 
push to GitHub.

In GitHub, navigate to your <username>.github.io repository and click Settings.

Within Settings, navigate to the Source section within the Github Pages section. From the dropdown menu, select 
master branch and then click Save.

Now, all of your repositories can be found at http://<username>.github.io/<repository-name>. Try creating a new 
repo with an HTML project inside it (perhaps push an old project to GitHub) and then navigate to the deployed page. 
	


-----LECCION 9-----
BEST PRACTICES FOR TEAMS ON GITHUB

WHAT IS A PULL REQUEST: Sonia, a new member of Codecademy’s engineering team, has just finished a snazzy navigation 
menu on a branch titled, “sonia_feature_navigation_menu”. Her changes will not be merged to the main branch until 
her pull request is approved. A pull request is a feature of GitHub and other source code management tools to 
review code before merging it from one branch to another, usually the main branch.

When Sonia creates a new pull request, her repository will automatically be set as the source repository and the 
project’s repository will be set as the destination repository. She will get the option to specify the source 
branch and the destination branch. She will be greeted with a preview of the changes between the two codebases and 
whether the branches can be merged automatically depending on code conflicts. In the Pull Request description 
field, Sonia must describe the code changes and what feature(s) this merge will add to the main branch. 

Sonia’s proposed changes can then be accepted or rejected by her teammates. Any further commits Sonia makes to the 
source branch will automatically be reflected in the pull request. Once her changes are accepted by the project’s 
collaborators, her branch can be merged into the repository’s main branch. GitHub will keep this pull request in 
history as a record of the code change, Sonia’s contribution, and the discussion that took place.

HOW TO MAKE A GOOD PULL REQUEST: Concisely explain the purpose of the pull request in the title. If the pull 
request adds a new feature, go for something like “Add frontend component for settings page”. If it’s to fix a 
typo, be specific and say “Fix name typos on the Contact Us page”.

The description is where all the juicy details are. You want the reviewers to know the thought process behind code 
changes and the options you have considered. It also helps to embed screenshots, GIFs, or even videos of your 
application so reviewers can anticipate what the code change in the pull request looks like.

Some developers even have preconfigured templates or checklists on their repositories to ensure all pull requests 
contain just the relevant information. Following these guidelines help speed up collaborative critiques so the code 
can get merged faster!

KEEP PULL REQUESTS SMALL AND FAST: Reduce the size of pull requests and respond to reviews quickly. Splitting big 
features into smaller parts is the best way to speed up review time. Not only does it result in less wasted work if 
the pull request gets rejected, but it will be easier to merge and review more thoroughly. Quickly respond to any 
feedback or requested changes. You want to ship code fast and make sure reviewers aren’t stuck discussing an open 
pull request for ages!

WALKTHROUGH OF TWO PULL REQUESTS: https://www.youtube.com/watch?time_continue=187&v=9EqP3GsE9N4&feature=emb_title


