WEB DEVELOPMENT CODECADEMY:

-----LECCION 1----- 
BASIC GIT WORKFLOW
Git is a software that allows you to keep track of changes made to a project over time. Git works by recording the 
changes you make to a project, storing those changes, then allowing you to reference them as needed.

GIT INIT: Now that we have started working on the screenplay, let’s turn the sorcerers-code directory into a Git 
project. We do this with:
  git init

The word 'init' means 'initialize'. The command sets up all the tools Git needs to begin tracking changes made to 
the project.

GIT WORKFLOW: Nice! We have a Git project. A Git project can be thought of as having three parts:
1. A Working Directory: where you’ll be doing all the work: creating, editing, deleting and organizing files
2. A Staging Area: where you’ll list changes you make to the working directory
3. A Repository: where Git permanently stores those changes as different versions of the project

The Git workflow consists of editing files in the working directory, adding files to the staging area, and saving 
changes to a Git repository. In Git, we save changes with a commit.

GIT STATUS: As you write the screenplay, you will be changing the contents of the working directory. 
You can check the status of those changes with:
  git status

GIT ADD: In order for Git to start tracking scene-1.txt, the file needs to be added to the staging area.
We can add a file to the staging area with:
  git add filename (The word *filename* here refers to the name of the file you are editing, such as scene-1.txt.)

GIT DIFF: Imagine that we type another line in scene-1.txt. Since the file is tracked, we can check the differences 
between the working directory and the staging area with:
  git diff filename

Here, filename is the actual name of the file. If the name of my file was changes.txt the command would be
  git diff changes.txt

GIT COMMIT: A commit is the last step in our Git workflow. A commit permanently stores changes from the staging 
area inside the repository. One more bit of code is needed for a commit: the option -m followed by a message. 
Here’s an example:
  git commit -m "Complete first line of dialogue"

Standard Conventions for Commit Messages:
  - Must be in quotation marks
  - Written in the present tense
  - Should be brief (50 characters or less) when using -m

GIT LOG: Often with Git, you’ll need to refer back to an earlier version of a project. 
Commits are stored chronologically in the repository and can be viewed with:
  git log

In the output, notice:
  - A 40-character code, called a SHA, that uniquely identifies the commit. This appears in orange text.
  - The commit author (you!)
  - The date and time of the commit
  - The commit message

REVIEW: 
Use Git commands to help keep track of changes made to a project:
  - git init:   creates a new Git repository
  - git status: inspects the contents of the working directory and staging area
  - git add:    adds files from the working directory to the staging area
  - git diff:   shows the difference between the working directory and the staging area
  - git commit: permanently stores file changes from the staging area in the repository
  - git log:    shows a list of all previous commits

SETUP WITH GIT AND GITHUB: https://www.codecademy.com/paths/web-development/tracks/learn-git/modules/learn-git-git-workflow-u/articles/f1-u3-git-setup

GIT & GITHUB: https://www.youtube.com/watch?v=-sMmrYTtQgE&t=116s


-----LECCION 2----- 
HOW TO BACKTRACK
BACKTRACKING INTRO: When working on a Git project, sometimes we make changes that we want to get rid of. Git offers 
a few eraser-like features that allow us to undo mistakes during project creation. 

HEAD COMMIT: In Git, the commit you are currently on is known as the HEAD commit. In many cases, the most recently 
made commit is the HEAD commit.

To see the HEAD commit, enter:
  git show HEAD

The output of this command will display everything the git log command displays for the HEAD commit, plus all the 
file changes that were committed.

GIT CHECKOUT: What if you decide to change the ghost’s line in the working directory, but then decide you wanted 
to discard that change? You could rewrite the line how it was originally, but what if you forgot the exact wording? 
The below will restore the file in your working directory to look exactly as it did when you last made a commit.
  git checkout HEAD filename

MORE GIT ADD: You can add multiple files like this: 
  git add filename_1 filename_2

GIT RESET I: What if, before you commit, you accidentally delete an important line from scene-2.txt? Unthinkingly, 
you add scene-2.txt to the staging area and you don’t want to include it in the commit. We can unstage that file 
from the staging area using:
  git reset HEAD filename

This command resets the file in the staging area to be the same as the HEAD commit. It does not discard file 
changes from the working directory, it just removes them from the staging area.

GIT RESET II: Just like retracing your steps on a hike, Git enables you to rewind to the part before you made the 
wrong turn. You can do this with:
  git reset commit_SHA

This command works by using the first 7 characters of the SHA of a previous commit. For example, if the SHA of the 
previous commit is 5d692065cf51a2f50ea8e7b19b5a7ae512f633ba, use:
  git reset 5d69206
HEAD is now set to that previous commit.

REVIEW: 
Let’s take a moment to review the new commands:
  - git checkout HEAD filename: Discards changes in the working directory. 
                                (el archivo vuelve a como estaba antes de los cambios)
  - git reset HEAD filename: Unstages file changes in the staging area.
                             (el archivo sale de la pila de archivos a commitear)
  - git reset commit_SHA: Resets to a previous commit in your commit history.


-----LECCION 3----- 
BRANCHING
GIT BRANCH: Git allows us to create branches to experiment with versions of a project. Imagine you want to create 
version of a story with a happy ending. You can create a new branch and make the happy ending changes to that 
branch only. It will have no effect on the master branch until you’re ready to merge the happy ending to the 
master branch.

You can use the command below to answer the question: “which branch am I on?”:
  git branch

To create a new branch, use:
  git branch new_branch

Be sure to name your branch something that describes the purpose of the branch. Also, branch names can’t contain 
whitespaces: *new-branch* and *new_branch* are valid branch names, but *new branch* is not.

GIT CHECKOUT: You can switch to the new branch with
  git checkout branch_name

Once you switch branches, you will now be able to make commits on the branch that have no impact on master. You can 
continue your workflow, while master stays intact!

GIT MERGE: What if you wanted include all the changes made to the 'fencing' branch on the 'master' branch? We can 
easily accomplish this by merging the branch into 'master' with:
  git merge fencing

Keep in mind:
  - Your goal is to update master with changes you made to fencing.
  - fencing is the giver branch, since it provides the changes.
  - master is the receiver branch, since it accepts those changes.

MERGE CONFLICTS: The merge was successful because 'master' had not changed since we made a commit on 'fencing'. Git 
knew to simply update 'master' with changes on 'fencing'.

What would happen if you made a commit on 'master' before you merged the two branches? Furthermore, what if the 
commit you made on 'master' altered the same exact text you worked on in 'fencing'? When you switch back to 
'master' and ask Git to merge the two branches, Git doesn’t know which changes you want to keep. 
This is called a 'merge conflict'.

Let’s say you decide you’d like to merge the changes from 'fencing' into 'master'. Here’s where the trouble begins!
You’ve made commits on separate branches that alter the same line in conflicting ways. Now, when you try to merge 
'fencing' into 'master', Git will not know which version of the file to keep.

FIXING THE MERGE CONFLICT: We must fix the merge conflict. In the code editor, look at 'resume.txt'. Git uses 
markings to indicate the HEAD (master) version of the file and the fencing version of the file, like this:
  <<<<<<< HEAD
  master version of line
  =======
  fencing version of line
  >>>>>>> fencing

Git asks us which version of the file to keep: the version on 'master' or the version on 'fencing'. You decide you
want the 'fencing' version.

From the code editor:
  - Delete the content of the line as it appears in the master branch
  - Delete all of Git’s special markings including the words HEAD and fencing. If any of Git’s markings remain, 
    for example, >>>>>>> and =======, the conflict remains.
Then you add 'resume.txt' to the staging area and you commit it with a message like "Resolve merge conflict"

DELETE BRANCH: In Git, branches are usually a means to an end. You create them to work on a new project feature, 
but the end goal is to merge that feature into the master branch. After the branch has been integrated into 
'master', it has served its purpose and can be deleted.
The command below will delete the specified branch from your Git project:
  git branch -d branch_name

REVIEW:
The following commands are useful in the Git branch workflow.
  - git branch: Lists all a Git project’s branches.
  - git branch branch_name: Creates a new branch.
  - git checkout branch_name: Used to switch from one branch to another.
  - git merge branch_name: Used to join file changes from one branch to another.
  - git branch -d branch_name: Deletes the branch specified.
