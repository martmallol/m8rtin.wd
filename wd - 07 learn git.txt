WEB DEVELOPMENT CODECADEMY:

-----LECCION 1----- 
BASIC GIT WORKFLOW
Git is a software that allows you to keep track of changes made to a project over time. Git works by recording the 
changes you make to a project, storing those changes, then allowing you to reference them as needed.

GIT INIT: Now that we have started working on the screenplay, let’s turn the sorcerers-code directory into a Git 
project. We do this with:
  git init

The word 'init' means 'initialize'. The command sets up all the tools Git needs to begin tracking changes made to 
the project.

GIT WORKFLOW: Nice! We have a Git project. A Git project can be thought of as having three parts:
1. A Working Directory: where you’ll be doing all the work: creating, editing, deleting and organizing files
2. A Staging Area: where you’ll list changes you make to the working directory
3. A Repository: where Git permanently stores those changes as different versions of the project

The Git workflow consists of editing files in the working directory, adding files to the staging area, and saving 
changes to a Git repository. In Git, we save changes with a commit.

GIT STATUS: As you write the screenplay, you will be changing the contents of the working directory. 
You can check the status of those changes with:
  git status

GIT ADD: In order for Git to start tracking scene-1.txt, the file needs to be added to the staging area.
We can add a file to the staging area with:
  git add filename (The word *filename* here refers to the name of the file you are editing, such as scene-1.txt.)

GIT DIFF: Imagine that we type another line in scene-1.txt. Since the file is tracked, we can check the differences 
between the working directory and the staging area with:
  git diff filename

Here, filename is the actual name of the file. If the name of my file was changes.txt the command would be
  git diff changes.txt

GIT COMMIT: A commit is the last step in our Git workflow. A commit permanently stores changes from the staging 
area inside the repository. One more bit of code is needed for a commit: the option -m followed by a message. 
Here’s an example:
  git commit -m "Complete first line of dialogue"

Standard Conventions for Commit Messages:
  - Must be in quotation marks
  - Written in the present tense
  - Should be brief (50 characters or less) when using -m

GIT LOG: Often with Git, you’ll need to refer back to an earlier version of a project. 
Commits are stored chronologically in the repository and can be viewed with:
  git log

In the output, notice:
  - A 40-character code, called a SHA, that uniquely identifies the commit. This appears in orange text.
  - The commit author (you!)
  - The date and time of the commit
  - The commit message

REVIEW: 
Use Git commands to help keep track of changes made to a project:
  - git init:   creates a new Git repository
  - git status: inspects the contents of the working directory and staging area
  - git add:    adds files from the working directory to the staging area
  - git diff:   shows the difference between the working directory and the staging area
  - git commit: permanently stores file changes from the staging area in the repository
  - git log:    shows a list of all previous commits

SETUP WITH GIT AND GITHUB: https://www.codecademy.com/paths/web-development/tracks/learn-git/modules/learn-git-git-workflow-u/articles/f1-u3-git-setup

GIT & GITHUB: https://www.youtube.com/watch?v=-sMmrYTtQgE&t=116s


-----LECCION 2----- 
HOW TO BACKTRACK
BACKTRACKING INTRO: When working on a Git project, sometimes we make changes that we want to get rid of. Git offers 
a few eraser-like features that allow us to undo mistakes during project creation. 

HEAD COMMIT: In Git, the commit you are currently on is known as the HEAD commit. In many cases, the most recently 
made commit is the HEAD commit.

To see the HEAD commit, enter:
  git show HEAD

The output of this command will display everything the git log command displays for the HEAD commit, plus all the 
file changes that were committed.

GIT CHECKOUT: What if you decide to change the ghost’s line in the working directory, but then decide you wanted 
to discard that change? You could rewrite the line how it was originally, but what if you forgot the exact wording? 
The below will restore the file in your working directory to look exactly as it did when you last made a commit.
  git checkout HEAD filename

MORE GIT ADD: You can add multiple files like this: 
  git add filename_1 filename_2

GIT RESET I: What if, before you commit, you accidentally delete an important line from scene-2.txt? Unthinkingly, 
you add scene-2.txt to the staging area and you don’t want to include it in the commit. We can unstage that file 
from the staging area using:
  git reset HEAD filename

This command resets the file in the staging area to be the same as the HEAD commit. It does not discard file 
changes from the working directory, it just removes them from the staging area.

GIT RESET II: Just like retracing your steps on a hike, Git enables you to rewind to the part before you made the 
wrong turn. You can do this with:
  git reset commit_SHA

This command works by using the first 7 characters of the SHA of a previous commit. For example, if the SHA of the 
previous commit is 5d692065cf51a2f50ea8e7b19b5a7ae512f633ba, use:
  git reset 5d69206
HEAD is now set to that previous commit.

REVIEW: 
Let’s take a moment to review the new commands:
  - git checkout HEAD filename: Discards changes in the working directory. 
                                (el archivo vuelve a como estaba antes de los cambios)
  - git reset HEAD filename: Unstages file changes in the staging area.
                             (el archivo sale de la pila de archivos a commitear)
  - git reset commit_SHA: Resets to a previous commit in your commit history.


-----LECCION 3----- 
BRANCHING
GIT BRANCH: Git allows us to create branches to experiment with versions of a project. Imagine you want to create 
version of a story with a happy ending. You can create a new branch and make the happy ending changes to that 
branch only. It will have no effect on the master branch until you’re ready to merge the happy ending to the 
master branch.

You can use the command below to answer the question: “which branch am I on?”:
  git branch

To create a new branch, use:
  git branch new_branch

Be sure to name your branch something that describes the purpose of the branch. Also, branch names can’t contain 
whitespaces: *new-branch* and *new_branch* are valid branch names, but *new branch* is not.

GIT CHECKOUT: You can switch to the new branch with
  git checkout branch_name

Once you switch branches, you will now be able to make commits on the branch that have no impact on master. You can 
continue your workflow, while master stays intact!

GIT MERGE: What if you wanted include all the changes made to the 'fencing' branch on the 'master' branch? We can 
easily accomplish this by merging the branch into 'master' with:
  git merge fencing

Keep in mind:
  - Your goal is to update master with changes you made to fencing.
  - fencing is the giver branch, since it provides the changes.
  - master is the receiver branch, since it accepts those changes.

MERGE CONFLICTS: The merge was successful because 'master' had not changed since we made a commit on 'fencing'. Git 
knew to simply update 'master' with changes on 'fencing'.

What would happen if you made a commit on 'master' before you merged the two branches? Furthermore, what if the 
commit you made on 'master' altered the same exact text you worked on in 'fencing'? When you switch back to 
'master' and ask Git to merge the two branches, Git doesn’t know which changes you want to keep. 
This is called a 'merge conflict'.

Let’s say you decide you’d like to merge the changes from 'fencing' into 'master'. Here’s where the trouble begins!
You’ve made commits on separate branches that alter the same line in conflicting ways. Now, when you try to merge 
'fencing' into 'master', Git will not know which version of the file to keep.

FIXING THE MERGE CONFLICT: We must fix the merge conflict. In the code editor, look at 'resume.txt'. Git uses 
markings to indicate the HEAD (master) version of the file and the fencing version of the file, like this:
  <<<<<<< HEAD
  master version of line
  =======
  fencing version of line
  >>>>>>> fencing

Git asks us which version of the file to keep: the version on 'master' or the version on 'fencing'. You decide you
want the 'fencing' version.

From the code editor:
  - Delete the content of the line as it appears in the master branch
  - Delete all of Git’s special markings including the words HEAD and fencing. If any of Git’s markings remain, 
    for example, >>>>>>> and =======, the conflict remains.
Then you add 'resume.txt' to the staging area and you commit it with a message like "Resolve merge conflict"

DELETE BRANCH: In Git, branches are usually a means to an end. You create them to work on a new project feature, 
but the end goal is to merge that feature into the master branch. After the branch has been integrated into 
'master', it has served its purpose and can be deleted.
The command below will delete the specified branch from your Git project:
  git branch -d branch_name

REVIEW:
The following commands are useful in the Git branch workflow.
  - git branch: Lists all a Git project’s branches.
  - git branch branch_name: Creates a new branch.
  - git checkout branch_name: Used to switch from one branch to another.
  - git merge branch_name: Used to join file changes from one branch to another.
  - git branch -d branch_name: Deletes the branch specified.



-----LECCION 4----- 
GIT TEAMWORK
REMOTES: A remote is a shared Git repository that allows multiple collaborators to work on the same Git project 
from different locations. Collaborators work on the project independently, and merge changes together when they 
are ready to do so.

GIT CLONE: Sally has created the remote repository, science-quizzes in the directory curriculum, which teachers on 
the school’s shared network have access to. In order to get your own replica of science-quizzes, you’ll need to 
clone it with:
  git clone remote_location clone_name

- remote_location tells Git where to go to find the remote. This could be a web address, or a filepath, such as:
     /Users/teachers/Documents/some-remote
- clone_name is the name you give to the directory (local) in which Git will clone the repository.

GIT REMOTE -V: We have a clone of Sally’s remote on our computer. One thing that Git does behind the scenes when 
you clone science-quizzes is give the remote address the name origin, so that you can refer to it more conveniently. 
In this case, Sally’s remote is origin.

You can see a list of a Git project’s remotes with the command:
   git remote -v

Notice the output:
    origin    /home/ccuser/workspace/curriculum/science-quizzes (fetch)
    origin    /home/ccuser/workspace/curriculum/science-quizzes (push)
- Git lists the name of the remote, origin, as well as its location.
- Git automatically names this remote origin, because it refers to the remote repository of origin. However, it is 
  possible to safely change its name.
- The remote is listed twice: once for (fetch) and once for (push). We’ll learn about these later in the lesson.

GIT FETCH: After you cloned science-quizzes, you had to run off to teach a class. Now that you’re back at your 
computer, there’s a problem: what if, while you were teaching, Sally changed the science-quizzes Git project in 
some way. If so, your clone will no longer be up-to-date.

An easy way to see if changes have been made to the remote and bring the changes down to your local copy is with:
   git fetch

This command will not merge changes from the remote into your local repository. 
It brings those changes onto what’s called a remote branch.

MERGE THE FETCHED CHANGES:  Even though Sally’s new commits have been fetched to your local copy of the Git project, 
those commits are on the origin/master branch. Your local master branch has not been updated yet, so you can’t view
or make changes to any of the work she has added.
We’ll use the git merge command to integrate origin/master into your local master branch. The command:
   git merge origin/master

GIT WORKFLOW: The workflow for Git collaborations typically follows this order:
1. Fetch and merge changes from the remote
2. Create a branch to work on a new project feature
3. Develop the feature on your branch and commit your work
4. Fetch and merge from the remote again (in case new commits were made while you were working)
5. Push your branch up to the remote for review

GIT PUSH: Now it’s time to share our work with Sally.

The command:
   git push origin your_branch_name
will push your branch up to the remote, origin. From there, Sally can review your branch and merge your work into 
the master branch, making it part of the definitive project version.

In the output, notice the line:
   To /home/ccuser/workspace/curriculum/science-quizzes
    * [new branch]      bio-questions -> bio-questions

Git informs us that the branch bio-questions was pushed up to the remote. Sally can now review your new work and 
can merge it into the remote’s master branch.

REVIEW:
- git clone: Creates a local copy of a remote.
- git remote -v: Lists a Git project’s remotes.
- git fetch: Fetches work from the remote into the local copy.
- git merge origin/master: Merges origin/master into your local branch.
- git push origin <branch_name>: Pushes a local branch to the origin remote.
