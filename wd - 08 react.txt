WEB DEVELOPMENT CODECADEMY

-----LECCION 1----- 
INTRO TO JSX: JSX is a syntax extension for JavaScript. It was written to be used with React. JSX code looks a lot
like HTML.

What does “syntax extension” mean?

In this case, it means that JSX is not valid JavaScript. Web browsers can’t read it!

If a JavaScript file contains JSX code, then that file will have to be compiled. That means that before the file
reaches a web browser, a JSX compiler will translate any JSX into regular JavaScript.

EJ: const h1 = <h1>Hello world</h1>;  // This JSX element looks exactly like HTML!

JSX ELEMENTS AND THEIR SURROUNDINGS: A JSX element can be saved in a variable, passed to a function, stored in an
object or array… you name it.

Here’s an example of several JSX elements being stored in an object:

const myTeam = {
  center: <li>Benzo Walli</li>,
  powerForward: <li>Rasha Loa</li>,
  smallForward: <li>Tayshaun Dasmoto</li>,
  shootingGuard: <li>Colmar Cumberbatch</li>,
  pointGuard: <li>Femi Billon</li>
};

ATTRIBUTES IN JSX: A single JSX element can have many attributes, just like in HTML:
const panda = <img src='images/panda.jpg' alt='panda' width='500px' height='500px' />;

NESTED JSX: You can nest JSX elements inside of other JSX elements, just like in HTML.
If a JSX expression takes up more than one line, then you must wrap the multi-line JSX expression in parentheses. 
This looks strange at first, but you get used to it.

Nested JSX expressions can be saved as variables, passed to functions, etc., just like non-nested JSX expressions 
can! Here’s an example of a nested JSX expression being saved as a variable:
 const theExample = (
   <a href="https://www.example.com">
     <h1>
       Click me!
     </h1>
   </a>
 );
 
JSX OUTER ELEMENTS: There’s a rule that we haven’t mentioned: a JSX expression must have exactly one outermost
element. In other words, this code will work:
const paragraphs = (
  <div id="i-am-the-outermost-element">
    <p>I am a paragraph.</p>
    <p>I, too, am a paragraph.</p>
  </div>
);

But this code will not work:
const paragraphs = (
  <p>I am a paragraph.</p> 
  <p>I, too, am a paragraph.</p>
);

The first opening tag and the final closing tag of a JSX expression must belong to the same JSX element!
 
RENDERING JSX: To render a JSX expression means to make it appear onscreen.
The following code will render a JSX expression:
ReactDOM.render(<h1>Hello world</h1>, document.getElementById('app'));
 
THE ReactDOM.render() FUNCTION: ReactDOM is the name of a JavaScript library. This library contains several 
React-specific methods, all of which deal with the DOM in some way or another.
Move slightly to the right, and you can see one of ReactDOM‘s methods: ReactDOM.render().

ReactDOM.render() is the most common way to render JSX. It takes a JSX expression, creates a corresponding tree of
DOM nodes, and adds that tree to the DOM. That is the way to make a JSX expression appear onscreen.
 
<h1>Hello world</h1> is the first argument being passed. ReactDOM.render()‘s first argument should be a JSX expression, and it will be rendered to the screen.
 
Move to the right a little more, and you will see this expression: document.getElementById('app'). 
You just learned that ReactDOM.render() makes its first argument appear onscreen. But where on the screen should
that first argument appear? The first argument is appended to whatever element is selected by the second argument.

On index.html, the element that acted as a container for ReactDOM.render()‘s first argument is the first header!
<main id="app">
  <h1>Render me!</h1>
</main>

PASSING A VARIABLE TO ReactDOM.render(): The first argument could also be a variable, so long as that variable
evaluates to a JSX expression.

const toDoList = (
  <ol>
    <li>Learn React</li>
    <li>Become a Developer</li>
  </ol>
);
 
ReactDOM.render(
  toDoList, 
  document.getElementById('app')
);


THE VIRTUAL DOM: One special thing about ReactDOM.render() is that it only updates DOM elements that have changed.
That means that if you render the exact same thing twice in a row, the second render will do nothing.
https://www.codecademy.com/articles/react-virtual-dom
 

-----LECCION 2----- 
ADVANCED JSX: In HTML, it’s common to use class as an attribute name: <h1 class="big">Hey</h1>
In JSX, you can’t use the word class! You have to use className instead: <h1 className="big">Hey</h1>
This is because JSX gets translated into JavaScript, and class is a reserved word in JavaScript.

SELF CLOSING TAGS: When you write a self-closing tag in HTML, it is optional to include a forward-slash immediately
before the final angle-bracket. In JSX, you have to include the slash. If you write a self-closing tag in JSX and
forget the slash, you will raise an error.
Fine in JSX: <br />  |  NOT FINE AT ALL in JSX: <br>

CURLY BRACES IN JSX: Any code in between the tags of a JSX element will be read as JSX, not as regular JavaScript!
JSX doesn’t add numbers - it reads them as text, just like HTML.

You need a way to write code that says, “Even though I am located in between JSX tags, treat me like ordinary
JavaScript and not like JSX.” You can do this by wrapping your code in curly braces.

VARIABLES IN JSX: You can access variables while inside of a JSX expression, even if those variables were declared
on the outside.
EJ: 
const **name** = 'Gerdo';
 
const greeting = <p>Hello, {**name**}!</p>;

VARIABLES ATTRIBUTES IN JSX: When writing JSX, it’s common to use variables to set attributes.

EJ: 
const **sideLength** = "200px";
 
const panda = (
  <img 
    src="images/panda.jpg" 
    alt="panda" 
    height={**sideLength**} 
    width={**sideLength**} />
);

EVENT LISTENERS ON JSX: Programming in React means constantly working with event listeners.

You create an event listener by giving a JSX element a special attribute. Here’s an example:
<img onClick={**myFunc**} />

IFS DON'T WORK ON JSX: The reason why has to do with the way that JSX is compiled. 
You can learn more here: https://reactjs.org/docs/jsx-in-depth.html

JSX CONDITIONALS: IF STATEMENTS THAT DO WORK: How can you write a conditional, if you can’t inject an if statement
into JSX? Well, one option is to write an if statement, and not inject it into JSX.

JSX CONDITIONALS: THE TERNARY OPERATOR: you write x ? y : z, where x, y, and z are all JavaScript expressions. 
When your code is executed, x is evaluated as either “truthy” or “falsy.” If x is truthy, then the entire ternary
operator returns y. If x is falsy, then the entire ternary operator returns z.

Here’s how you might use the ternary operator in a JSX expression:
const headline = (
  <h1>
    { age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }
  </h1>
);

JSX CONDITIONALS: &&: It works best in conditionals that will sometimes do an action, but other times do nothing at
all.
EJ:
const tasty = (
  <ul>
    <li>Applesauce</li>
    { !baby && <li>Pizza</li> }
    { age > 15 && <li>Brussels Sprouts</li> }
    { age > 20 && <li>Oysters</li> }
    { age > 25 && <li>Grappa</li> }
  </ul>
);

If the expression on the left of the && evaluates as true, then the JSX on the right of the && will be rendered. 
If the first expression is false, however, then the JSX to the right of the && will be ignored and not rendered.

KEYS: When you make a list in JSX, sometimes your list will need to include something called keys:
<ul>
  <li key="li-01">Example1</li>
  <li key="li-02">Example2</li>
  <li key="li-03">Example3</li>
</ul>

keys don’t do anything that you can see! React uses them internally to keep track of lists. If you don’t use keys when you’re supposed to, React might accidentally scramble your list-items into the wrong order.

Not all lists need to have keys. A list needs keys if either of the following are true:
 1. The list-items have memory from one render to the next. For instance, when a to-do list renders, each item 
    must “remember” whether it was checked off. The items shouldn’t get amnesia when they render.
 2. A list’s order might be shuffled. For instance, a list of search results might be shuffled from one render 
    to the next.

THE React.createElement METHOD: You can write React code without using JSX at all.
From: const h1 = <h1>Hello world</h1>;
To: const h1 = React.createElement(
      "h1",
      null,
      "Hello, world"
    );




