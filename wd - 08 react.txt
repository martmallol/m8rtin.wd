WEB DEVELOPMENT CODECADEMY

-----LECCION 1----- 
INTRO TO JSX: JSX is a syntax extension for JavaScript. It was written to be used with React. JSX code looks a lot
like HTML.

What does “syntax extension” mean?

In this case, it means that JSX is not valid JavaScript. Web browsers can’t read it!

If a JavaScript file contains JSX code, then that file will have to be compiled. That means that before the file
reaches a web browser, a JSX compiler will translate any JSX into regular JavaScript.

EJ: const h1 = <h1>Hello world</h1>;  // This JSX element looks exactly like HTML!

JSX ELEMENTS AND THEIR SURROUNDINGS: A JSX element can be saved in a variable, passed to a function, stored in an
object or array… you name it.

Here’s an example of several JSX elements being stored in an object:

const myTeam = {
  center: <li>Benzo Walli</li>,
  powerForward: <li>Rasha Loa</li>,
  smallForward: <li>Tayshaun Dasmoto</li>,
  shootingGuard: <li>Colmar Cumberbatch</li>,
  pointGuard: <li>Femi Billon</li>
};

ATTRIBUTES IN JSX: A single JSX element can have many attributes, just like in HTML:
const panda = <img src='images/panda.jpg' alt='panda' width='500px' height='500px' />;

NESTED JSX: You can nest JSX elements inside of other JSX elements, just like in HTML.
If a JSX expression takes up more than one line, then you must wrap the multi-line JSX expression in parentheses. 
This looks strange at first, but you get used to it.

Nested JSX expressions can be saved as variables, passed to functions, etc., just like non-nested JSX expressions 
can! Here’s an example of a nested JSX expression being saved as a variable:
 const theExample = (
   <a href="https://www.example.com">
     <h1>
       Click me!
     </h1>
   </a>
 );
 
JSX OUTER ELEMENTS: There’s a rule that we haven’t mentioned: a JSX expression must have exactly one outermost
element. In other words, this code will work:
const paragraphs = (
  <div id="i-am-the-outermost-element">
    <p>I am a paragraph.</p>
    <p>I, too, am a paragraph.</p>
  </div>
);

But this code will not work:
const paragraphs = (
  <p>I am a paragraph.</p> 
  <p>I, too, am a paragraph.</p>
);

The first opening tag and the final closing tag of a JSX expression must belong to the same JSX element!
 
RENDERING JSX: To render a JSX expression means to make it appear onscreen.
The following code will render a JSX expression:
ReactDOM.render(<h1>Hello world</h1>, document.getElementById('app'));
 
THE ReactDOM.render() FUNCTION: ReactDOM is the name of a JavaScript library. This library contains several 
React-specific methods, all of which deal with the DOM in some way or another.
Move slightly to the right, and you can see one of ReactDOM‘s methods: ReactDOM.render().

ReactDOM.render() is the most common way to render JSX. It takes a JSX expression, creates a corresponding tree of
DOM nodes, and adds that tree to the DOM. That is the way to make a JSX expression appear onscreen.
 
<h1>Hello world</h1> is the first argument being passed. ReactDOM.render()‘s first argument should be a JSX expression, and it will be rendered to the screen.
 
Move to the right a little more, and you will see this expression: document.getElementById('app'). 
You just learned that ReactDOM.render() makes its first argument appear onscreen. But where on the screen should
that first argument appear? The first argument is appended to whatever element is selected by the second argument.

On index.html, the element that acted as a container for ReactDOM.render()‘s first argument is the first header!
<main id="app">
  <h1>Render me!</h1>
</main>

PASSING A VARIABLE TO ReactDOM.render(): The first argument could also be a variable, so long as that variable
evaluates to a JSX expression.

const toDoList = (
  <ol>
    <li>Learn React</li>
    <li>Become a Developer</li>
  </ol>
);
 
ReactDOM.render(
  toDoList, 
  document.getElementById('app')
);


THE VIRTUAL DOM: One special thing about ReactDOM.render() is that it only updates DOM elements that have changed.
That means that if you render the exact same thing twice in a row, the second render will do nothing.
https://www.codecademy.com/articles/react-virtual-dom
 

-----LECCION 2----- 
ADVANCED JSX: In HTML, it’s common to use class as an attribute name: <h1 class="big">Hey</h1>
In JSX, you can’t use the word class! You have to use className instead: <h1 className="big">Hey</h1>
This is because JSX gets translated into JavaScript, and class is a reserved word in JavaScript.

SELF CLOSING TAGS: When you write a self-closing tag in HTML, it is optional to include a forward-slash immediately
before the final angle-bracket. In JSX, you have to include the slash. If you write a self-closing tag in JSX and
forget the slash, you will raise an error.
Fine in JSX: <br />  |  NOT FINE AT ALL in JSX: <br>

CURLY BRACES IN JSX: Any code in between the tags of a JSX element will be read as JSX, not as regular JavaScript!
JSX doesn’t add numbers - it reads them as text, just like HTML.

You need a way to write code that says, “Even though I am located in between JSX tags, treat me like ordinary
JavaScript and not like JSX.” You can do this by wrapping your code in curly braces.

VARIABLES IN JSX: You can access variables while inside of a JSX expression, even if those variables were declared
on the outside.
EJ: 
const **name** = 'Gerdo';
 
const greeting = <p>Hello, {**name**}!</p>;

VARIABLES ATTRIBUTES IN JSX: When writing JSX, it’s common to use variables to set attributes.

EJ: 
const **sideLength** = "200px";
 
const panda = (
  <img 
    src="images/panda.jpg" 
    alt="panda" 
    height={**sideLength**} 
    width={**sideLength**} />
);

EVENT LISTENERS ON JSX: Programming in React means constantly working with event listeners.

You create an event listener by giving a JSX element a special attribute. Here’s an example:
<img onClick={**myFunc**} />

IFS DON'T WORK ON JSX: The reason why has to do with the way that JSX is compiled. 
You can learn more here: https://reactjs.org/docs/jsx-in-depth.html

JSX CONDITIONALS: IF STATEMENTS THAT DO WORK: How can you write a conditional, if you can’t inject an if statement
into JSX? Well, one option is to write an if statement, and not inject it into JSX.

JSX CONDITIONALS: THE TERNARY OPERATOR: you write x ? y : z, where x, y, and z are all JavaScript expressions. 
When your code is executed, x is evaluated as either “truthy” or “falsy.” If x is truthy, then the entire ternary
operator returns y. If x is falsy, then the entire ternary operator returns z.

Here’s how you might use the ternary operator in a JSX expression:
const headline = (
  <h1>
    { age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }
  </h1>
);

JSX CONDITIONALS: &&: It works best in conditionals that will sometimes do an action, but other times do nothing at
all.
EJ:
const tasty = (
  <ul>
    <li>Applesauce</li>
    { !baby && <li>Pizza</li> }
    { age > 15 && <li>Brussels Sprouts</li> }
    { age > 20 && <li>Oysters</li> }
    { age > 25 && <li>Grappa</li> }
  </ul>
);

If the expression on the left of the && evaluates as true, then the JSX on the right of the && will be rendered. 
If the first expression is false, however, then the JSX to the right of the && will be ignored and not rendered.

KEYS: When you make a list in JSX, sometimes your list will need to include something called keys:
<ul>
  <li key="li-01">Example1</li>
  <li key="li-02">Example2</li>
  <li key="li-03">Example3</li>
</ul>

keys don’t do anything that you can see! React uses them internally to keep track of lists. If you don’t use keys when you’re supposed to, React might accidentally scramble your list-items into the wrong order.

Not all lists need to have keys. A list needs keys if either of the following are true:
 1. The list-items have memory from one render to the next. For instance, when a to-do list renders, each item 
    must “remember” whether it was checked off. The items shouldn’t get amnesia when they render.
 2. A list’s order might be shuffled. For instance, a list of search results might be shuffled from one render 
    to the next.

THE React.createElement METHOD: You can write React code without using JSX at all.
From: const h1 = <h1>Hello world</h1>;
To: const h1 = React.createElement(
      "h1",
      null,
      "Hello, world"
    );



-----LECCION 3-----
REACT COMPONENTS: A component is a small, reusable chunk of code that is responsible for one job. That job is 
often to render some HTML.

IMPORT ReactDOM: The methods imported from 'react-dom' are meant for interacting with the DOM. You are already 
familiar with one of them: ReactDOM.render().

The methods imported from 'react' don’t deal with the DOM at all. They don’t engage directly with anything that 
isn’t part of React.

To clarify: the DOM is used in React applications, but it isn’t part of React. After all, the DOM is also used in 
countless non-React applications. Methods imported from 'react' are only for pure React purposes, such as creating 
components or writing JSX elements. 

CREATE A COMPONENT CLASS: We can use a JavaScript class to define a new React component. After we define our class 
component, we can use it to render as many instances of that component as we want. A component class is more like a 
factory that produces components. When you start making components, each one will come from a component class.
React.Component is a JavaScript class. To create your own component class, you must subclass React.Component. You 
can do this by using the syntax class YourComponentNameGoesHere extends React.Component {}.

Component class variable names must begin with capital letters!
EJ:
class MyComponentClass extends React.Component {
  render() {
    return <h1>Hello world</h1>;
  }
}

COMPONENT CLASS INSTRUCTIONS (BODY): Like all JavaScript classes, this one needs a body. The body will act as a set 
of instructions, explaining to your component class how it should build a React component.

There is only one property that you have to include in your instructions: a render method.

A render method is a property whose name is render, and whose value is a function. The term “render method” can refer to the entire property, or to just the function part.

A render method must contain a return statement. Usually, this return statement returns a JSX expression:

class ComponentFactory extends React.Component {
  render() {
    return <h1>Hello world</h1>;
  }
}

COMPONENT INSTANCE: To make a React component, you write a JSX element. Instead of naming your JSX element 
something like h1 or div like you’ve done before, give it the same name as a component class. Voilà, there’s your 
component instance! 		EJ: 	<MyComponentClass />

JSX elements can be either HTML-like, or component instances. JSX uses capitalization to distinguish between the 
two! That is the React-specific reason why component class names must begin with capital letters.

RENDER A COMPONENT: Whenever you make a component, that component inherits all of the methods of its component 
class. MyComponentClass has one method: MyComponentClass.render(). Therefore, <MyComponentClass /> also has a 
method named render.
You could make a million different <MyComponentClass /> instances, and each one would inherit this same exact render method.
In order to render a component, that component needs to have a method named render. Your component has this!

ReactDOM.render(
  <MyComponentClass />,
  document.getElementById('app')
);



-----LECCION 4-----
ADVANCED JSX & COMPONENTS
TRANSFORMING A MULTILINE JSX INTO A COMPONENT: The key thing to notice in QuoteMaker is the parentheses in 
the return statement

class QuoteMaker extends React.Component {
  render() {
    return (	<-- ACA!!!
      <blockquote>
        <p>
          The world is full of objects, more or less interesting; I do not wish to add any more.
        </p>
        <cite>
          <a target="_blank"
            href="https://en.wikipedia.org/wiki/Douglas_Huebler">
            Douglas Huebler
          </a>
        </cite>
      </blockquote>
    );	<-- ACA TERMINA!!!
  }
};

VARIABLE ATTRIBUTE (FROM AN OBJECT) IN A COMPONENT: 
From redPanda object: 
	const redPanda = {
  	  src: 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Endangered_Red_Panda.jpg',	<-- ACA!!!
  	  alt: 'Red Panda',	<-- ACA!!!
  	  width: '200px	<-- ACA!!!
	};

To RedPanda component: 
	class RedPanda extends React.Component {
	  render() {
	    return (
	      <div>
	        <h1>Cute Red Panda</h1>
	        <img 
	          src={redPanda.src}	<-- ACA!!!
	          alt={redPanda.alt}	<-- ACA!!!	
	          width={redPanda.width} />	<-- ACA!!!
	      </div>
	    );
	  }
	}

LOGIC IN A RENDER FUNCTION: 
class Random extends React.Component {
  render() {
    // First, some logic that must happen before rendering:
    const n = Math.floor(Math.random() * 10 + 1); <-- ACA!!!
    // Next, a return statement using that logic:
    return <h1>The number is {n}!</h1>;
  }
}



-----LECCION 5-----
REACT SETUP AND RAVENOUS

https://www.codecademy.com/paths/web-development/tracks/front-end-applications-with-react/modules/react-development-setup-and-ravenous-part-1/articles/how-to-create-a-react-app

CREATING A REACT APP: We will be using the Node package manager (npm), so you will need to have Node installed on 
your computer. When you install Node, you automatically get npm installed on your computer as well. 
To upgrade to the latest version of npm on Linux, you can run this command in your terminal:
	sudo npm install -g npm@latest

SETTING UP THE BOILERPLATE APPLICATION: It is possible to manually create a React app, but Facebook has created a 
Node package create-react-app to generate a boilerplate version of a React application. This has the added benefit 
of providing a consistent structure for React apps that you will recognize as you move between React projects. It 
also provides an out-of-the-box build script and development server.

We will use npx, a package runner tool that comes with npm 5.2+ and higher, to install and run create-react-app.
You can simply run this command:
	npx create-react-app myfirstreactapp

REACT APP STRUCTURE: Most of what you see will not be visible to the visitor of your web app. React uses a tool 
called webpack which transforms the directories and files here into static assets. Visitors to your site are served 
those static assets.

.gitignore FILE: This is the standard file used by the source control tool git to determine which files and 
directories to ignore when committing code. While this file exists, create-react-app did not create a git repo 
within this folder.

package.json FILE: This file outlines all the settings for the React app.

- name: is the name of your app
- version: is the current version
- "private": true: is a failsafe setting to avoid accidentally publishing your app as a public package within the 
                   npm ecosystem.
- dependencies: contains all the required Node modules and versions required for the application.
- scripts: specifies aliases that you can use to access some of the react-scripts commands in a more efficient 
	   manner. 
- browserslist: provides information about browser compatibility of the app 
- eslintConfig: takes care of the code linting. (Linting is the process of running a program that will analyse code 
		 for potential errors.)

node-modules DIRECTORY: This directory contains dependencies and sub-dependencies of packages used by the current 
React app, as specified by package.json. This folder is automatically added to the .gitignore for good reason! 

package-lock.json FILE: This provides a way for teams working on private apps to ensure that they have the same 
version of dependencies and sub-dependencies. It also contains a history of changes to package.json, so you can 
quickly look back at dependency changes.

public DIRECTORY: It contains assets that will be served directly without additional processing by webpack.

src DIRECTORY: This contains the JavaScript that will be processed by webpack and is the heart of the React app. 
Browsing this folder, you see the main App JavaScript component (App.js), its associated styles (App.css), and test 
suite (App.test.js). index.js and its styles (index.css) provide an entry into the App and also kick off the 
registerServiceWorker.js. This service worker takes care of caching and updating files for the end-user. It allows 
for offline capability and faster page loads after the initial visit.

components/ & views/ DIRECTORIES: As your React app grows, it is common to add a components/ directory to organize 
components and component-related files and a views/ directory to organize React views and view-related files.

STARTING THE REACT APP DEVELOPMENT SERVER: You just need to run npm start in your app directory to begin serving 
the development server. It should auto-open a tab in your browser that points to http://localhost:3000/ (if not, 
manually visit that address).



-----LECCION 6-----
REACT DEVELOPER TOOLS: Use React Developer Tools to debug your React applications

INSTALL IT: Facebook created a Chrome extension to help with debugging React Apps. It allows developers to inspect 
React components, view their properties, and interact with them while looking at the application in Google Chrome.
Link: https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi

To open the React Developer Tools, first open Chrome DevTools (View > Developer > Developer Tools). On the same 
banner as Elements, Sources, Console, etc., there will be two new React tabs: Components and Profiler. These two 
tabs will only appear on sites using React.

For more tips about React Dev Tools: https://www.codecademy.com/paths/web-development/tracks/front-end-applications-with-react/modules/react-development-setup-and-ravenous-part-1/informationals/ready-react-developer-tools




